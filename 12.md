### Binary Search Tree

- 특정한 순서 조건을 따르는 binary tree
- 왼쪽 자식의 키값 < 부모의 키값 < 오른쪽 자식의 키값
- 본 강의에서는 같으면 오른쪽 자식에 저장

### Search in BST

```c
Element bstSearch(BST bst, int K){
  Element found;
  if (bst == nil)
    found = null;
  else {
    root = bst.root;
    if (K == rook.key)
      found = root;
    else if (K < root.key)
      bstSearch(root.leftSubTree, K);
    else
      bstSearch(root.rightSubTree, K);
  }
  return found;
}
```

- nil이라는 더미 노드 하나를 구현하고 모든 left를 이것으로 연결하면 효율적인 공간 관리 가능

##### Analysis

- 한쪽으로만 길게 늘어진 트리의 경우 $$\Theta(n)$$
  - 오른쪽(왼쪽) 자식만 있음
- 좌우 균형이 맞게 생성된 트리의 경우 $$\Theta(\log n)$$
- Balanced Binary Search Tree가 될 수록 빠름
  - 이를 만드는 것이 중요함

### Red-Black Tree
