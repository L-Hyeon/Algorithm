### KMP Alogrithm (cont.)

```python
def KMP(T, P):
  F = failure(P)
  i, j = 0
  while (i < N):
    if (T[i] == P[j]):
      if (j == M - 1):
        return i - j
      i += 1
      j += 1
    elif (j > 0):
      j = F[j - 1]
    else:
      i = i + 1
  return -1
```

##### 시간 복잡도

- while 내부의 1번, 3번 케이스에서 최대 N번 반복 가능
  - T의 크기가 N
- 2번 케이스(elif)는 최대 M번 반복 가능
  - 패턴의 크기가 M
- i가 1증가할 때 j도 1만 증가
  - 모든 i마다 2번 케이스가 나와도 1번만 반복
- $$O(N + M)$$.

##### Failure Function

```python
def failure(P):
  F[0] = 0
  i, j = 1, 0
  while (i < M):
    if (P[i] == P[j]):
      F[i] = j + 1
      i += 1
      j += 1
    elif (j > 0):
      j = F[j - 1]
    else:
      F[i] = 0
      i += 1
  return F
```

- while 내에서 최대 2M번 반복 가능
- $$O(M)$$.

### Boyer-Moore Algorithm

##### Heuristics

-
